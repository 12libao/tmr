
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>TMR Interface and Methods &#8212; TMR 1 documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Error Estimation" href="error_estimation.html" />
    <link rel="prev" title="Algorithms" href="algorithms.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="error_estimation.html" title="Error Estimation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="algorithms.html" title="Algorithms"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">TMR 1 documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">TMR Interface and Methods</a><ul>
<li><a class="reference internal" href="#tmrentity">TMREntity</a></li>
<li><a class="reference internal" href="#geometry-level-classes">Geometry-level classes</a></li>
<li><a class="reference internal" href="#mesh-generation-level-classes">Mesh generation-level classes</a></li>
<li><a class="reference internal" href="#quad-octree-level-classes">Quad/octree-level classes</a><ul>
<li><a class="reference internal" href="#typical-usage">Typical Usage</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="algorithms.html"
                        title="previous chapter">Algorithms</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="error_estimation.html"
                        title="next chapter">Error Estimation</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/interface_and_methods.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tmr-interface-and-methods">
<h1>TMR Interface and Methods<a class="headerlink" href="#tmr-interface-and-methods" title="Permalink to this headline">¶</a></h1>
<p>There are two interfaces to <a class="reference internal" href="#module-TMR" title="TMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">TMR</span></code></a>: the C++ interface and the Python-level
interface. <a class="reference internal" href="#module-TMR" title="TMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">TMR</span></code></a> is implemented in C++, so the interface through C++
contains all publicly accessible class member functions. The Python-level
interface wraps the most important classes and functions, but does not provide
an interface to all lower-level operations.</p>
<p>There are three primary types of classes within <a class="reference internal" href="#module-TMR" title="TMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">TMR</span></code></a>:</p>
<ol class="arabic simple">
<li><p>Geometry and topology-level classes which interface with the underlying
geometry kernel</p></li>
<li><p>Serial mesh-level classes which are used to create moderate-size
quadrilateral and hexahedral meshes based on the input geometry</p></li>
<li><p>Quadtree and Octree-level classes which are used to create, modify, refine
and extract information from the quad/octrees.</p></li>
</ol>
<div class="section" id="tmrentity">
<h2>TMREntity<a class="headerlink" href="#tmrentity" title="Permalink to this headline">¶</a></h2>
<p>Almost all classes in <a class="reference internal" href="#module-TMR" title="TMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">TMR</span></code></a> inherit from <code class="xref py py-class docutils literal notranslate"><span class="pre">Entity</span></code>. Those that do
not are low-level data structures that are used within high-level
operations. <code class="xref py py-class docutils literal notranslate"><span class="pre">Entity</span></code> defines a reference counting scheme for
all objects allocated on the heap. This is handled automatically through the
Python interface.</p>
</div>
<div class="section" id="geometry-level-classes">
<h2>Geometry-level classes<a class="headerlink" href="#geometry-level-classes" title="Permalink to this headline">¶</a></h2>
<p>The primary geometry-level classes used within <a class="reference internal" href="#module-TMR" title="TMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">TMR</span></code></a> consist of
entity-level classes and container-level classes. The abstract interface classes
to the underlying geometry consist of:</p>
<ul>
<li><span class="target" id="module-TMR"></span><dl class="class">
<dt id="TMR.Vertex">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">Vertex</code><a class="headerlink" href="#TMR.Vertex" title="Permalink to this definition">¶</a></dt>
<dd><p>The vertex class is used to store both the point and to
represent the underlying geometry</p>
<dl class="method">
<dt id="TMR.Vertex.evalPoint">
<code class="sig-name descname">evalPoint</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.Vertex.evalPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the point on the parametric surface and returns the node
location</p>
</dd></dl>

</dd></dl>

</li>
<li><dl class="class">
<dt id="TMR.Edge">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">Edge</code><a class="headerlink" href="#TMR.Edge" title="Permalink to this definition">¶</a></dt>
<dd><p>The edge class is used to store both the points on an edge and to
represent the underlying geometry</p>
<dl class="method">
<dt id="TMR.Edge.evalPoint">
<code class="sig-name descname">evalPoint</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.Edge.evalPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a node location on a curve with a single
parametric argument <em>t</em>. Provides access to the first and second vertices
that begin/end the edge.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<em>double</em>) – parameteric location</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</li>
<li><dl class="class">
<dt id="TMR.Face">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">Face</code><a class="headerlink" href="#TMR.Face" title="Permalink to this definition">¶</a></dt>
<dd><p>The face class is used to store both the points and edges and to
represent the underlying geometry</p>
<dl class="method">
<dt id="TMR.Face.evalPoint">
<code class="sig-name descname">evalPoint</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">u</em>, <em class="sig-param">v</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.Face.evalPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a node location given a parametric location
(<em>u,v</em>). Access the edge loops that bound the face.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>u</strong> (<em>double</em>) – Parametric location in u</p></li>
<li><p><strong>v</strong> (<em>double</em>) – Parametric location in v</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</li>
</ul>
<p>The other objects define collections of geometric entities:</p>
<ul>
<li><dl class="class">
<dt id="TMR.EdgeLoop">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">EdgeLoop</code><a class="headerlink" href="#TMR.EdgeLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains an oriented set of edges that enclose a surface. Provides the edge
list and their relative orientations in the loop</p>
</dd></dl>

</li>
<li><dl class="class">
<dt id="TMR.Volume">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">Volume</code><a class="headerlink" href="#TMR.Volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains an oriented collection of surfaces that enclose a
volume. Provides a list of surfaces. All faces must be oriented
with positive orientation outwards.</p>
</dd></dl>

</li>
<li><dl class="class">
<dt id="TMR.Model">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">Model</code><a class="headerlink" href="#TMR.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains an ordered collection of vertices, edges, faces, and volumes that
define a model geometry.</p>
</dd></dl>

</li>
</ul>
<p>The class <a class="reference internal" href="#TMR.Model" title="TMR.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a> is often created by a call to the
function <a class="reference internal" href="#TMR.LoadModel" title="TMR.LoadModel"><code class="xref py py-func docutils literal notranslate"><span class="pre">LoadModel()</span></code></a>. This function
loads the model data from the STEP file and creates the OpenCASCADE versions of
the geometric entities and containers that define the model. This call attempts
to remove any extraneous geometry defined in the STEP file but not contained
within the model. This function creates and initializes the internal topology of
the model, which can then be used in subsequent meshing operations.</p>
<ul>
<li><dl class="function">
<dt id="TMR.LoadModel">
<code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">LoadModel</code><span class="sig-paren">(</span><em class="sig-param">fname</em>, <em class="sig-param">print_lev</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.LoadModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialization of the OpenCascade geometry from an IGES/STEP files</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – Name of the geometry file</p></li>
<li><p><strong>print_level</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Print level for operation</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</li>
</ul>
<p>A direct connection between the geometry and octree or quadtree levels is
provided through <a class="reference internal" href="#TMR.Topology" title="TMR.Topology"><code class="xref py py-class docutils literal notranslate"><span class="pre">Topology</span></code></a> that defines the topology for
mapped-quadrilateral and hexahedral geometries. This class can be created
directly, but it is most common to create this using the mesh-level classes
described below.</p>
</div>
<div class="section" id="mesh-generation-level-classes">
<h2>Mesh generation-level classes<a class="headerlink" href="#mesh-generation-level-classes" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#TMR.Mesh" title="TMR.Mesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mesh</span></code></a> provides the primary interface to the meshing
functionality in <a class="reference internal" href="#module-TMR" title="TMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">TMR</span></code></a> and is used to create quadrilateral and hexahedral
meshes. The actual meshing operations are performed on the root processor with
rank 0, but all connectivity and location information is broadcast to all
processors. The primary functions are as follows:</p>
<ul>
<li><dl class="class">
<dt id="TMR.Mesh">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">Mesh</code><a class="headerlink" href="#TMR.Mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Mesh the geometry model. This class handles the meshing for surface objects
without any additional information. For hexahedral meshes, the model must
have a source or target.</p>
<dl class="method">
<dt id="TMR.Mesh.createModelFromMesh">
<code class="sig-name descname">createModelFromMesh</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.Mesh.createModelFromMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a geometry model based on the input mesh</p>
</dd></dl>

<dl class="method">
<dt id="TMR.Mesh.getHexConnectivity">
<code class="sig-name descname">getHexConnectivity</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.Mesh.getHexConnectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the global connectivity from the hexahedral mesh</p>
</dd></dl>

<dl class="method">
<dt id="TMR.Mesh.getMeshPoints">
<code class="sig-name descname">getMeshPoints</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.Mesh.getMeshPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve a global array of the mesh locations</p>
</dd></dl>

<dl class="method">
<dt id="TMR.Mesh.getQuadConnectivity">
<code class="sig-name descname">getQuadConnectivity</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.Mesh.getQuadConnectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the global connectivity from the quadrilateral mesh</p>
</dd></dl>

<dl class="method">
<dt id="TMR.Mesh.getTriConnectivity">
<code class="sig-name descname">getTriConnectivity</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.Mesh.getTriConnectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the global connectivity from the triangular mesh</p>
</dd></dl>

<dl class="method">
<dt id="TMR.Mesh.mesh">
<code class="sig-name descname">mesh</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">h</em>, <em class="sig-param">opts</em>, <em class="sig-param">fs</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.Mesh.mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Mesh the model with the provided mesh spacing <em>h</em>, default meshing
options <a class="reference internal" href="#TMR.MeshOptions" title="TMR.MeshOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeshOptions</span></code></a> opts if it is not provided or given
<a class="reference internal" href="#TMR.ElementFeatureSize" title="TMR.ElementFeatureSize"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementFeatureSize</span></code></a> fs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>h</strong> (<em>double</em>) – Mesh spacing</p></li>
<li><p><strong>opts</strong> (<a class="reference internal" href="#TMR.MeshOptions" title="TMR.MeshOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeshOptions</span></code></a>) – Meshing options</p></li>
<li><p><strong>fs</strong> (<a class="reference internal" href="#TMR.ElementFeatureSize" title="TMR.ElementFeatureSize"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementFeatureSize</span></code></a>) – Element Feature Size options</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="TMR.Mesh.writeToBDF">
<code class="sig-name descname">writeToBDF</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fname</em>, <em class="sig-param">outtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.Mesh.writeToBDF" title="Permalink to this definition">¶</a></dt>
<dd><p>Write both the quadrilateral and hexahedral mesh to a BDF file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – filename</p></li>
<li><p><strong>outtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – Type of mesh to output to BDF file i.e. quad or hex</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="TMR.Mesh.writeToVTK">
<code class="sig-name descname">writeToVTK</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fname</em>, <em class="sig-param">outtype=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.Mesh.writeToVTK" title="Permalink to this definition">¶</a></dt>
<dd><p>Write both the quadrilateral and hexahedral mesh to a VTK file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – filename</p></li>
<li><p><strong>outtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – Type of mesh to output to VTK file i.e. quad or hex</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</li>
</ul>
<p><a class="reference internal" href="#TMR.MeshOptions" title="TMR.MeshOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeshOptions</span></code></a> class defines a number of options that modify
the meshing algorithm. These include the following:</p>
<ul>
<li><dl class="class">
<dt id="TMR.MeshOptions">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">MeshOptions</code><a class="headerlink" href="#TMR.MeshOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a number of options that modify the meshing algorithm.</p>
<dl class="attribute">
<dt id="TMR.MeshOptions.frontal_quality_factor">
<code class="sig-name descname">frontal_quality_factor</code><a class="headerlink" href="#TMR.MeshOptions.frontal_quality_factor" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the mesh quality indicator to determine when to accept new triangles
in the frontal algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<em>double</em>) – Quality factor</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="TMR.MeshOptions.mesh_type_default">
<code class="sig-name descname">mesh_type_default</code><a class="headerlink" href="#TMR.MeshOptions.mesh_type_default" title="Permalink to this definition">¶</a></dt>
<dd><p>Default mesh type either structured or unstructured. In the case that it
is set to structured, the algorithm firsts checks if it is possible to
use a mapped mesh, and reverts to an unstructured algorithm otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="TMR.MeshOptions.num_smoothing_steps">
<code class="sig-name descname">num_smoothing_steps</code><a class="headerlink" href="#TMR.MeshOptions.num_smoothing_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of smoothing steps to apply during both the Laplacian and quad
smoothing algorithms</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Number of smoothing steps</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="TMR.MeshOptions.triangularize_print_level">
<code class="sig-name descname">triangularize_print_level</code><a class="headerlink" href="#TMR.MeshOptions.triangularize_print_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Print level to provide more verbosity during the triangularization
algorithm</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Print level for the operation</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="TMR.MeshOptions.write_mesh_quality_histogram">
<code class="sig-name descname">write_mesh_quality_histogram</code><a class="headerlink" href="#TMR.MeshOptions.write_mesh_quality_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Write out a histogram of the mesh quality in the final smoothed
quadrilateral mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>value</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Whether or not to write the mesh quality histogram</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</li>
</ul>
<p><a class="reference internal" href="#TMR.ElementFeatureSize" title="TMR.ElementFeatureSize"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementFeatureSize</span></code></a> class is a base class that defines the feature
size of the elements in the mesh and can be used in place of <a class="reference internal" href="#TMR.MeshOptions" title="TMR.MeshOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">MeshOptions</span></code></a></p>
<ul>
<li><dl class="class">
<dt id="TMR.ElementFeatureSize">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">ElementFeatureSize</code><a class="headerlink" href="#TMR.ElementFeatureSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for creating feature size</p>
</dd></dl>

</li>
</ul>
<p>The mesh itself is created by meshing the vertices, edges, faces, and volumes
within the mesh.  These meshes are stored in the following classes:</p>
<ul>
<li><dl class="class">
<dt id="TMR.EdgeMesh">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">EdgeMesh</code><a class="headerlink" href="#TMR.EdgeMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the class that stores the node numbers along an edge</p>
</dd></dl>

</li>
<li><dl class="class">
<dt id="TMR.FaceMesh">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">FaceMesh</code><a class="headerlink" href="#TMR.FaceMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the class that stores the structured/unstructured surface mesh</p>
</dd></dl>

</li>
<li><dl class="class">
<dt id="TMR.VolumeMesh">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">VolumeMesh</code><a class="headerlink" href="#TMR.VolumeMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the class that stores the hexahedral mesh</p>
</dd></dl>

</li>
</ul>
<p><a class="reference internal" href="#module-TMR" title="TMR"><code class="xref py py-class docutils literal notranslate"><span class="pre">TMR</span></code></a> only supports swept volume mesh generation. This requires the
specification of additional information to indicate what surfaces should be
linked and what direction should be swept. This information is provided by
indicating source and target geometry entities. When a source/target pair is
set, the mesh connectivity is copied from the source to the target. A swept
volume can only be created if:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#TMR.Volume" title="TMR.Volume"><code class="xref py py-class docutils literal notranslate"><span class="pre">Volume</span></code></a> contains a source/target <a class="reference internal" href="#TMR.Face" title="TMR.Face"><code class="xref py py-class docutils literal notranslate"><span class="pre">Face</span></code></a> object
pair that share the same number of edge loops and each source/target edge
pair has the same number of nodes.</p></li>
<li><p>All other <a class="reference internal" href="#TMR.Face" title="TMR.Face"><code class="xref py py-class docutils literal notranslate"><span class="pre">Face</span></code></a> objects are structured with the same number
of nodes along the swept direction.</p></li>
</ol>
<p>To ensure these conditions apply, it is often necessary to set source/target
pairs for faces and edges.</p>
<p>The <a class="reference internal" href="#TMR.EdgeMesh" title="TMR.EdgeMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">EdgeMesh</span></code></a> object is created by first computing the number of
nodes along its length, and then globally ordering the nodes. The number of
nodes is determined based on the following criteria:</p>
<ol class="arabic simple">
<li><p>If the first and second vertices are different, then at least 3 nodes are
created along the edge.</p></li>
<li><p>If the first and second vertices are the same and the edge is not
degenerate, then it forms a loop back on itself and at least 5 nodes are
created (double counting the first and last node number).</p></li>
<li><p>If the edge is a target edge, the number of nodes is taken from the source
edge.</p></li>
<li><p>Otherwise, the number of nodes is selected as an odd number that most
closely matches the spacing requested along the edge.</p></li>
</ol>
</div>
<div class="section" id="quad-octree-level-classes">
<h2>Quad/octree-level classes<a class="headerlink" href="#quad-octree-level-classes" title="Permalink to this headline">¶</a></h2>
<p>The quadtree and octree level classes are used to create, refine and manipulate
the semi-structured mesh in parallel. The quadrants or octants are stored in a
distributed manner across processors. The following section describes the
functions for the forest of octree operations. Analogous functionality is
defined for the forest of quadtree object as well. The first step in creating a
<a class="reference internal" href="#TMR.OctForest" title="TMR.OctForest"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctForest</span></code></a> object is typically creating a <a class="reference internal" href="#TMR.Topology" title="TMR.Topology"><code class="xref py py-class docutils literal notranslate"><span class="pre">Topology</span></code></a>
which defines a model with mapped 2D and 3D geometry that consists entirely of
non-degenerate quadrilateral surfaces with four non-degenerate edges and
hexahedral volumes with 6 enclosing surfaces. This type of object can be
created using the constructor as follows:</p>
<ul>
<li><dl class="class">
<dt id="TMR.Topology">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">Topology</code><a class="headerlink" href="#TMR.Topology" title="Permalink to this definition">¶</a></dt>
<dd><p>The main topology class that contains the objects used to build the
underlying mesh.</p>
<p>This class takes in a general <a class="reference internal" href="#TMR.Model" title="TMR.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a>, but there are additional
requirements that are placed on the model to create a proper
topology object. These requirements are as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>No edge can degenerate to a vertex.</p></li>
<li><p>No face can degenerate to an edge or vertex.</p></li>
<li><p>All faces must be surrounded by a single edge loop with 4</p></li>
<li><p>All volumes must contain 6 non-degenerate faces that are
ordered in coordinate ordering as shown below. Furthermore, all
volumes must be of type <code class="xref py py-class docutils literal notranslate"><span class="pre">TFIVolume</span></code>.</p></li>
</ol>
</div></blockquote>
</dd></dl>

</li>
</ul>
<p>The <a class="reference internal" href="#TMR.Topology" title="TMR.Topology"><code class="xref py py-class docutils literal notranslate"><span class="pre">Topology</span></code></a> object defines additional functionality that is
generally required only for lower-level operations. Once the topology object has
been created, the <a class="reference internal" href="#TMR.OctForest" title="TMR.OctForest"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctForest</span></code></a> can be initialized. It has the
following functions:</p>
<ul>
<li><dl class="class">
<dt id="TMR.OctForest">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">OctForest</code><a class="headerlink" href="#TMR.OctForest" title="Permalink to this definition">¶</a></dt>
<dd><p>This class defines a forest of octrees. The octrees within the
forest can be distributed across processors. The connectivity
between octrees is defined on all processors by setting a octree to
node connectivity.</p>
<p>The octrees can be redistributed across processors by using the
repartition function. This destroys the nodes that may have been
created (but can easily be recomputed).</p>
<dl class="method">
<dt id="TMR.OctForest.balance">
<code class="sig-name descname">balance</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">btype</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.OctForest.balance" title="Permalink to this definition">¶</a></dt>
<dd><p>Balance all the elements in the mesh to achieve a 2-to-1 balance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>btype</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Whether or not to balance corners</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="TMR.OctForest.coarsen">
<code class="sig-name descname">coarsen</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.OctForest.coarsen" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new forest object by coarsening all the elements within the
mesh by one level, if possible. Does not create new nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>dup</strong> – The coarsened OctForest</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#TMR.OctForest" title="TMR.OctForest"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctForest</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="TMR.OctForest.createInterpolation">
<code class="sig-name descname">createInterpolation</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">forest</em>, <em class="sig-param">vec</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.OctForest.createInterpolation" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an interpolation object between two octrees that share a common
topology.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>forest</strong> (<a class="reference internal" href="#TMR.OctForest" title="TMR.OctForest"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctForest</span></code></a>) – The octree forest that has the common topology</p></li>
<li><p><strong>vec</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">VecInterp</span></code>) – The interpolation operator created</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="TMR.OctForest.createNodes">
<code class="sig-name descname">createNodes</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.OctForest.createNodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Create all the nodes within the mesh</p>
</dd></dl>

<dl class="method">
<dt id="TMR.OctForest.createRandomTrees">
<code class="sig-name descname">createRandomTrees</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">nrand</em>, <em class="sig-param">min_level</em>, <em class="sig-param">max_level</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.OctForest.createRandomTrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a set of trees with random levels of refinement. This is useful
for testing purposes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nrand</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Number of random octrees</p></li>
<li><p><strong>min_level</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Minimum refinement level</p></li>
<li><p><strong>max_level</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Maximum refinement level</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="TMR.OctForest.createTrees">
<code class="sig-name descname">createTrees</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">depth_level</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.OctForest.createTrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Create all the octrees in the mesh with the given level of refinement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>refine_level</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Octree of refinement level depth</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="TMR.OctForest.duplicate">
<code class="sig-name descname">duplicate</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.OctForest.duplicate" title="Permalink to this definition">¶</a></dt>
<dd><p>Duplicate a forest by copying connectivity, topology and elements (but
not duplicating nodes)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>dup</strong> – The duplicate OctForest</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#TMR.OctForest" title="TMR.OctForest"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctForest</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="TMR.OctForest.getDepNodeConn">
<code class="sig-name descname">getDepNodeConn</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.OctForest.getDepNodeConn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dependent node connectivity, weights and number of dependent
nodes from the octree object</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>ptr</strong> (<em>array of int</em>) – Array of dependent nodes</p></li>
<li><p><strong>conn</strong> (<em>array of int</em>) – Array of connectivity of dependent nodes</p></li>
<li><p><strong>weights</strong> (<em>array of double</em>) – Array of weights associated with the dependent nodes</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="TMR.OctForest.getMeshConn">
<code class="sig-name descname">getMeshConn</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.OctForest.getMeshConn" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the distributed mesh connectivity using a global ordering</p>
</dd></dl>

<dl class="method">
<dt id="TMR.OctForest.getNodesWithName">
<code class="sig-name descname">getNodesWithName</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">aname</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.OctForest.getNodesWithName" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an array of nodes with the desired name</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>aname</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – Get the nodes with aname</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>array</strong> – Array of node numbers with name</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array of int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="TMR.OctForest.getOctsWithName">
<code class="sig-name descname">getOctsWithName</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">aname</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.OctForest.getOctsWithName" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an array of octants with the desired name</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>aname</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – Get the octants with aname</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>array</strong> – Array of octants with name</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">OctantArray</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="TMR.OctForest.refine">
<code class="sig-name descname">refine</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">refine</em>, <em class="sig-param">min_level</em>, <em class="sig-param">max_level</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.OctForest.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine the elements in the mesh by the specified number of levels. If a
negative number is supplied, coarsen the element.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>refine</strong> (<em>array of int</em>) – Array of integers</p></li>
<li><p><strong>min_level</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Minimum level of refinement</p></li>
<li><p><strong>max_level</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Maximum refinement level</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="TMR.OctForest.repartition">
<code class="sig-name descname">repartition</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">max_rank=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.OctForest.repartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Repartition the mesh across processors. This redistributes the elements
so that there are an equal, or nearly equal, number of elements on each
processor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>max_rank</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Number of processors to distribute the mesh across. If negative, the
mesh is distribute across all processors</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="TMR.OctForest.setTopology">
<code class="sig-name descname">setTopology</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">topo</em><span class="sig-paren">)</span><a class="headerlink" href="#TMR.OctForest.setTopology" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the topology (and determine the connectivity)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>topo</strong> (<a class="reference internal" href="#TMR.Topology" title="TMR.Topology"><code class="xref py py-class docutils literal notranslate"><span class="pre">Topology</span></code></a>) – Set topo as the underlying topology object</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</li>
</ul>
<p>Similarly, <a class="reference internal" href="#TMR.QuadForest" title="TMR.QuadForest"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuadForest</span></code></a> can be initialized and has the similar functions:</p>
<ul>
<li><dl class="class">
<dt id="TMR.QuadForest">
<em class="property">class </em><code class="sig-prename descclassname">TMR.</code><code class="sig-name descname">QuadForest</code><a class="headerlink" href="#TMR.QuadForest" title="Permalink to this definition">¶</a></dt>
<dd><p>A parallel forest of quadtrees</p>
<p>This class defines a parallel forest of quadrtrees. The connectivity
between quadtrees is defined at a global level. The quadrants can
easily be redistributed across processors using the repartition()
call.</p>
</dd></dl>

</li>
</ul>
<div class="section" id="typical-usage">
<h3>Typical Usage<a class="headerlink" href="#typical-usage" title="Permalink to this headline">¶</a></h3>
<p>The typical usage for a <a class="reference internal" href="#TMR.OctForest" title="TMR.OctForest"><code class="xref py py-class docutils literal notranslate"><span class="pre">OctForest</span></code></a> would consist of the following:</p>
<ol class="arabic simple">
<li><p>Create the object and call <a class="reference internal" href="#TMR.OctForest.setTopology" title="TMR.OctForest.setTopology"><code class="xref py py-func docutils literal notranslate"><span class="pre">setTopology()</span></code></a> to set the
super mesh</p></li>
<li><p>Create an initial element mesh by calling <a class="reference internal" href="#TMR.OctForest.createTrees" title="TMR.OctForest.createTrees"><code class="xref py py-func docutils literal notranslate"><span class="pre">createTrees()</span></code></a></p></li>
<li><p>Create a refined mesh by duplicating and refining the octree forest by
calling <a class="reference internal" href="#TMR.OctForest.duplicate" title="TMR.OctForest.duplicate"><code class="xref py py-func docutils literal notranslate"><span class="pre">duplicate()</span></code></a> followed by
<a class="reference internal" href="#TMR.OctForest.refine" title="TMR.OctForest.refine"><code class="xref py py-func docutils literal notranslate"><span class="pre">refine()</span></code></a>. Note that the length of the integer array
passed to refine must be equal to the number of elements in the original mesh.</p></li>
<li><p>Balance the mesh and create nodes by calling <a class="reference internal" href="#TMR.OctForest.balance" title="TMR.OctForest.balance"><code class="xref py py-func docutils literal notranslate"><span class="pre">balance()</span></code></a>
then <a class="reference internal" href="#TMR.OctForest.createNodes" title="TMR.OctForest.createNodes"><code class="xref py py-func docutils literal notranslate"><span class="pre">createNodes()</span></code></a></p></li>
<li><p>Create a sequence of coarser lower-order meshes by repeated calling
<a class="reference internal" href="#TMR.OctForest.duplicate" title="TMR.OctForest.duplicate"><code class="xref py py-func docutils literal notranslate"><span class="pre">duplicate()</span></code></a> and <a class="reference internal" href="#TMR.OctForest.coarsen" title="TMR.OctForest.coarsen"><code class="xref py py-func docutils literal notranslate"><span class="pre">coarsen()</span></code></a></p></li>
<li><p>Create interpolants between meshes for multigrid methods by calling
<a class="reference internal" href="#TMR.OctForest.createInterpolation" title="TMR.OctForest.createInterpolation"><code class="xref py py-func docutils literal notranslate"><span class="pre">createInterpolation()</span></code></a></p></li>
</ol>
<p>See <a class="reference internal" href="example.html"><span class="doc">Example</span></a> for an example of this usage.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="error_estimation.html" title="Error Estimation"
             >next</a> |</li>
        <li class="right" >
          <a href="algorithms.html" title="Algorithms"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">TMR 1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Graeme J. Kennedy.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>