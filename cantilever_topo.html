
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Cantilever topology optimization &#8212; TMR 1 documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Algorithms" href="algorithms.html" />
    <link rel="prev" title="Interpolation between meshes" href="interp.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="algorithms.html" title="Algorithms"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="interp.html" title="Interpolation between meshes"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">TMR 1 documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="interp.html"
                        title="previous chapter">Interpolation between meshes</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="algorithms.html"
                        title="next chapter">Algorithms</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/cantilever_topo.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="cantilever-topology-optimization">
<h1>Cantilever topology optimization<a class="headerlink" href="#cantilever-topology-optimization" title="Permalink to this headline">Â¶</a></h1>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Cantilever example using mass-constrained compliance minimization.</span>

<span class="sd">This example demonstrates:</span>

<span class="sd">1) Creating meshes using the TMR.Creator classes</span>
<span class="sd">2) Lagrange-type filters</span>
<span class="sd">3) Design-feature based adaptive refinement</span>

<span class="sd">Recommended arguments:</span>

<span class="sd">mpirun -np n python cantilever.py</span>

<span class="sd">This code performs a minimum compliance optimization with a fixed mass</span>
<span class="sd">constraint. The design domain is a prismatic beam with a square cross-section.</span>
<span class="sd">The domain has an aspect ratio of 5. After one cycle of optimization, the</span>
<span class="sd">domain is refined, refining elements where there is material, and coarsening</span>
<span class="sd">where there is void.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
<span class="kn">from</span> <span class="nn">tmr</span> <span class="kn">import</span> <span class="n">TMR</span><span class="p">,</span> <span class="n">TopOptUtils</span>
<span class="kn">from</span> <span class="nn">paropt</span> <span class="kn">import</span> <span class="n">ParOpt</span>
<span class="kn">from</span> <span class="nn">tacs</span> <span class="kn">import</span> <span class="n">TACS</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">constitutive</span><span class="p">,</span> <span class="n">functions</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">class</span> <span class="nc">OctCreator</span><span class="p">(</span><span class="n">TMR</span><span class="o">.</span><span class="n">OctTopoCreator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An instance of an OctCreator class.</span>

<span class="sd">    This creates discretization for a Largange type filter, where the density is</span>
<span class="sd">    interpolated from the nodes of a coarser finite-element mesh. In this type of</span>
<span class="sd">    creator, the filter element mesh and the octree element mesh need be the same.</span>
<span class="sd">    (In a conformal filter, they must have the same element mesh but may have</span>
<span class="sd">    different degree of approximation.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">props</span><span class="p">):</span>
        <span class="n">TMR</span><span class="o">.</span><span class="n">OctTopoCreator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">bcs</span><span class="p">,</span> <span class="n">filt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">props</span>

    <span class="k">def</span> <span class="nf">createElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">octant</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the element for the given octant.</span>

<span class="sd">        This callback provides the global indices for the filter mesh and the weights</span>
<span class="sd">        applied to each nodal density value to obtain the element density. The</span>
<span class="sd">        local octant is also provided (but not used here).</span>

<span class="sd">        Args:</span>
<span class="sd">            order (int): Order of the underlying mesh</span>
<span class="sd">            octant (Octant): The TMR.Octant class</span>
<span class="sd">            index (list): List of the global node numbers referenced by the element</span>
<span class="sd">            weights (list): List of weights to compute the element density</span>

<span class="sd">        Returns:</span>
<span class="sd">            TACS.Element: Element for the given octant</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stiff</span> <span class="o">=</span> <span class="n">TMR</span><span class="o">.</span><span class="n">OctStiffness</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">elements</span><span class="o">.</span><span class="n">Solid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">stiff</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">elem</span>

<span class="k">class</span> <span class="nc">CreatorCallback</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">props</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bcs</span> <span class="o">=</span> <span class="n">bcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">props</span>

    <span class="k">def</span> <span class="nf">creator_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forest</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the creator class and filter for the provided OctForest object.</span>

<span class="sd">        This is called for every mesh level when the topology optimization</span>
<span class="sd">        problem is created.</span>

<span class="sd">        Args:</span>
<span class="sd">            forest (OctForest): The OctForest for this mesh level</span>

<span class="sd">        Returns:</span>
<span class="sd">            OctTopoCreator, OctForest: The creator and filter for this forest</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">filtr</span> <span class="o">=</span> <span class="n">forest</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
        <span class="n">filtr</span><span class="o">.</span><span class="n">coarsen</span><span class="p">()</span>
        <span class="n">creator</span> <span class="o">=</span> <span class="n">OctCreator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bcs</span><span class="p">,</span> <span class="n">filtr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">creator</span><span class="p">,</span> <span class="n">filtr</span>

<span class="k">def</span> <span class="nf">create_forest</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an initial forest for analysis. and optimization</span>

<span class="sd">    This code loads in the model, sets names, meshes the geometry and creates</span>
<span class="sd">    a QuadForest from the mesh. The forest is populated with quadtrees with</span>
<span class="sd">    the specified depth.</span>

<span class="sd">    Args:</span>
<span class="sd">        comm (MPI_Comm): MPI communicator</span>
<span class="sd">        depth (int): Depth of the initial trees</span>
<span class="sd">        htarget (float): Target global element mesh size</span>

<span class="sd">    Returns:</span>
<span class="sd">        OctForest: Initial forest for topology optimization</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load the geometry model</span>
    <span class="n">geo</span> <span class="o">=</span> <span class="n">TMR</span><span class="o">.</span><span class="n">LoadModel</span><span class="p">(</span><span class="s1">&#39;cantilever.stp&#39;</span><span class="p">)</span>

    <span class="c1"># Mark the boundary condition faces</span>
    <span class="n">verts</span> <span class="o">=</span> <span class="n">geo</span><span class="o">.</span><span class="n">getVertices</span><span class="p">()</span>
    <span class="n">faces</span> <span class="o">=</span> <span class="n">geo</span><span class="o">.</span><span class="n">getFaces</span><span class="p">()</span>
    <span class="n">volumes</span> <span class="o">=</span> <span class="n">geo</span><span class="o">.</span><span class="n">getVolumes</span><span class="p">()</span>

    <span class="c1"># Set source and target faces</span>
    <span class="n">faces</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;fixed&#39;</span><span class="p">)</span>
    <span class="n">faces</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">setSource</span><span class="p">(</span><span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">faces</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
    <span class="n">verts</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;pt1&#39;</span><span class="p">)</span>
    <span class="n">verts</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;pt2&#39;</span><span class="p">)</span>

    <span class="c1"># Create the mesh</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">TMR</span><span class="o">.</span><span class="n">Mesh</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">geo</span><span class="p">)</span>

    <span class="c1"># Set the meshing options</span>
    <span class="n">opts</span> <span class="o">=</span> <span class="n">TMR</span><span class="o">.</span><span class="n">MeshOptions</span><span class="p">()</span>

    <span class="c1"># Create the surface mesh</span>
    <span class="n">htarget</span> <span class="o">=</span> <span class="mf">5.0</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="n">htarget</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>

    <span class="c1"># Create a model from the mesh</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">createModelFromMesh</span><span class="p">()</span>

    <span class="c1"># Create the corresponding mesh topology from the mesh-model</span>
    <span class="n">topo</span> <span class="o">=</span> <span class="n">TMR</span><span class="o">.</span><span class="n">Topology</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>

    <span class="c1"># Create the quad forest and set the topology of the forest</span>
    <span class="n">forest</span> <span class="o">=</span> <span class="n">TMR</span><span class="o">.</span><span class="n">OctForest</span><span class="p">(</span><span class="n">comm</span><span class="p">)</span>
    <span class="n">forest</span><span class="o">.</span><span class="n">setTopology</span><span class="p">(</span><span class="n">topo</span><span class="p">)</span>

    <span class="c1"># Create the trees, rebalance the elements and repartition</span>
    <span class="n">forest</span><span class="o">.</span><span class="n">createTrees</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">forest</span>

<span class="k">def</span> <span class="nf">create_problem</span><span class="p">(</span><span class="n">forest</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">props</span><span class="p">,</span> <span class="n">nlevels</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create the TMRTopoProblem object and set up the topology optimization problem.</span>

<span class="sd">    This code is given the forest, boundary conditions, material properties and</span>
<span class="sd">    the number of multigrid levels. Based on this info, it creates the TMRTopoProblem</span>
<span class="sd">    and sets up the mass-constrained compliance minimization problem. Before</span>
<span class="sd">    the problem class is returned it is initialized so that it can be used for</span>
<span class="sd">    optimization.</span>

<span class="sd">    Args:</span>
<span class="sd">        forest (OctForest): Forest object</span>
<span class="sd">        bcs (BoundaryConditions): Boundary condition object</span>
<span class="sd">        props (StiffnessProperties): Material properties object</span>
<span class="sd">        nlevels (int): number of multigrid levels</span>

<span class="sd">    Returns:</span>
<span class="sd">        TopoProblem: Topology optimization problem instance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Create the problem and filter object</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">CreatorCallback</span><span class="p">(</span><span class="n">bcs</span><span class="p">,</span> <span class="n">props</span><span class="p">)</span>
    <span class="n">problem</span> <span class="o">=</span> <span class="n">TopOptUtils</span><span class="o">.</span><span class="n">createTopoProblem</span><span class="p">(</span><span class="n">forest</span><span class="p">,</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">creator_callback</span><span class="p">,</span> <span class="n">filter_type</span><span class="p">,</span> <span class="n">nlevels</span><span class="o">=</span><span class="n">nlevels</span><span class="p">)</span>

    <span class="c1"># Get the assembler object we just created</span>
    <span class="n">assembler</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">getAssembler</span><span class="p">()</span>

    <span class="c1"># Set the load</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mf">1.0e3</span>
    <span class="n">force</span> <span class="o">=</span> <span class="n">TopOptUtils</span><span class="o">.</span><span class="n">computeVertexLoad</span><span class="p">(</span><span class="s1">&#39;pt1&#39;</span><span class="p">,</span> <span class="n">forest</span><span class="p">,</span> <span class="n">assembler</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">TopOptUtils</span><span class="o">.</span><span class="n">computeVertexLoad</span><span class="p">(</span><span class="s1">&#39;pt2&#39;</span><span class="p">,</span> <span class="n">forest</span><span class="p">,</span> <span class="n">assembler</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">P</span><span class="p">])</span>
    <span class="n">force</span><span class="o">.</span><span class="n">axpy</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span>

    <span class="c1"># Set the load cases into the topology optimization problem</span>
    <span class="n">problem</span><span class="o">.</span><span class="n">setLoadCases</span><span class="p">([</span><span class="n">force</span><span class="p">])</span>

    <span class="c1"># Compute the fixed mass target</span>
    <span class="n">lx</span> <span class="o">=</span> <span class="mf">50.0</span> <span class="c1"># mm</span>
    <span class="n">ly</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="c1"># mm</span>
    <span class="n">lz</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="c1"># mm</span>
    <span class="n">vol</span> <span class="o">=</span> <span class="n">lx</span><span class="o">*</span><span class="n">ly</span><span class="o">*</span><span class="n">lz</span>
    <span class="n">vol_frac</span> <span class="o">=</span> <span class="mf">0.25</span>
    <span class="n">density</span> <span class="o">=</span> <span class="mf">2600.0</span>
    <span class="n">m_fixed</span> <span class="o">=</span> <span class="n">vol_frac</span><span class="o">*</span><span class="p">(</span><span class="n">vol</span><span class="o">*</span><span class="n">density</span><span class="p">)</span>

    <span class="c1"># Set the mass constraint</span>
    <span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">functions</span><span class="o">.</span><span class="n">StructuralMass</span><span class="p">(</span><span class="n">assembler</span><span class="p">)]</span>
    <span class="n">problem</span><span class="o">.</span><span class="n">addConstraints</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">m_fixed</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="n">m_fixed</span><span class="p">])</span>

    <span class="c1"># Set the objective (scale the compliance objective)</span>
    <span class="n">problem</span><span class="o">.</span><span class="n">setObjective</span><span class="p">([</span><span class="mf">1.0e3</span><span class="p">])</span>

    <span class="c1"># Initialize the problem and set the prefix</span>
    <span class="n">problem</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">problem</span>

<span class="c1"># Set the optimization parameters</span>
<span class="n">optimization_options</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># Parameters for the trust region method</span>
    <span class="s1">&#39;tr_init_size&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="s1">&#39;tr_max_size&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="s1">&#39;tr_min_size&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="s1">&#39;tr_eta&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">,</span>
    <span class="s1">&#39;tr_penalty_gamma&#39;</span><span class="p">:</span> <span class="mf">20.0</span><span class="p">,</span>

    <span class="c1"># Parameters for the interior point method (used to solve the</span>
    <span class="c1"># trust region subproblem)</span>
    <span class="s1">&#39;max_qn_subspace&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
    <span class="s1">&#39;qn_diag_factor&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">,</span>
    <span class="s1">&#39;bfgs_update_type&#39;</span><span class="p">:</span> <span class="s1">&#39;Damped&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tol&#39;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span>
    <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span>
    <span class="s1">&#39;norm_type&#39;</span><span class="p">:</span> <span class="s1">&#39;L1&#39;</span><span class="p">,</span>
    <span class="s1">&#39;barrier_strategy&#39;</span><span class="p">:</span> <span class="s1">&#39;Complementarity fraction&#39;</span><span class="p">,</span>
    <span class="s1">&#39;start_strategy&#39;</span><span class="p">:</span> <span class="s1">&#39;Affine step&#39;</span><span class="p">}</span>

<span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;results&#39;</span>
<span class="n">optimization_options</span><span class="p">[</span><span class="s1">&#39;output_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="s1">&#39;output_file.dat&#39;</span><span class="p">)</span>
<span class="n">optimization_options</span><span class="p">[</span><span class="s1">&#39;tr_output_file&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="s1">&#39;tr_output_file.dat&#39;</span><span class="p">)</span>

<span class="c1"># Set the communicator</span>
<span class="n">comm</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span>

<span class="c1"># Set the type of filter to use</span>
<span class="n">filter_type</span> <span class="o">=</span> <span class="s1">&#39;lagrange&#39;</span>

<span class="n">order</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># Order of the mesh</span>
<span class="n">nlevels</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1"># Number of multigrid levels</span>
<span class="n">forest</span> <span class="o">=</span> <span class="n">create_forest</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">nlevels</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Set the boundary conditions for the problem</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="n">TMR</span><span class="o">.</span><span class="n">BoundaryConditions</span><span class="p">()</span>
<span class="n">bcs</span><span class="o">.</span><span class="n">addBoundaryCondition</span><span class="p">(</span><span class="s1">&#39;fixed&#39;</span><span class="p">)</span>

<span class="c1"># Create the material properties</span>
<span class="n">density</span> <span class="o">=</span> <span class="mf">2600.0</span>
<span class="n">rho</span> <span class="o">=</span> <span class="p">[</span><span class="n">density</span><span class="p">]</span>
<span class="n">E</span> <span class="o">=</span> <span class="p">[</span><span class="mf">70e9</span><span class="p">]</span>
<span class="n">nu</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">]</span>
<span class="n">props</span> <span class="o">=</span> <span class="n">TMR</span><span class="o">.</span><span class="n">StiffnessProperties</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">nu</span><span class="p">)</span>

<span class="c1"># Set the original filter to NULL</span>
<span class="n">orig_filter</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">xopt</span> <span class="o">=</span> <span class="bp">None</span>

<span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iterations</span><span class="p">):</span>
    <span class="c1"># Create the problem</span>
    <span class="n">problem</span> <span class="o">=</span> <span class="n">create_problem</span><span class="p">(</span><span class="n">forest</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">props</span><span class="p">,</span> <span class="n">nlevels</span><span class="p">)</span>
    <span class="n">problem</span><span class="o">.</span><span class="n">setPrefix</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>

    <span class="c1"># Extract the filter to interpolate design variables</span>
    <span class="n">filtr</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">getFilter</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">orig_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Create one of the new design vectors</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">createDesignVec</span><span class="p">()</span>
        <span class="n">TopOptUtils</span><span class="o">.</span><span class="n">interpolateDesignVec</span><span class="p">(</span><span class="n">orig_filter</span><span class="p">,</span> <span class="n">xopt</span><span class="p">,</span> <span class="n">filtr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">problem</span><span class="o">.</span><span class="n">setInitDesignVars</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">orig_filter</span> <span class="o">=</span> <span class="n">filtr</span>

    <span class="c1"># Optimize</span>
    <span class="n">opt</span> <span class="o">=</span> <span class="n">TopOptUtils</span><span class="o">.</span><span class="n">TopologyOptimizer</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">optimization_options</span><span class="p">)</span>
    <span class="n">xopt</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

    <span class="c1"># Refine based solely on the value of the density variable</span>
    <span class="n">assembler</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">getAssembler</span><span class="p">()</span>
    <span class="n">TopOptUtils</span><span class="o">.</span><span class="n">densityBasedRefine</span><span class="p">(</span><span class="n">forest</span><span class="p">,</span> <span class="n">assembler</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># Repartition the mesh</span>
    <span class="n">forest</span><span class="o">.</span><span class="n">repartition</span><span class="p">()</span>

<span class="c1"># Output for visualization</span>
<span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">TACS</span><span class="o">.</span><span class="n">ToFH5</span><span class="o">.</span><span class="n">NODES</span> <span class="o">|</span>
        <span class="n">TACS</span><span class="o">.</span><span class="n">ToFH5</span><span class="o">.</span><span class="n">DISPLACEMENTS</span> <span class="o">|</span>
        <span class="n">TACS</span><span class="o">.</span><span class="n">ToFH5</span><span class="o">.</span><span class="n">STRAINS</span> <span class="o">|</span>
        <span class="n">TACS</span><span class="o">.</span><span class="n">ToFH5</span><span class="o">.</span><span class="n">STRESSES</span> <span class="o">|</span>
        <span class="n">TACS</span><span class="o">.</span><span class="n">ToFH5</span><span class="o">.</span><span class="n">EXTRAS</span><span class="p">)</span>
<span class="n">assembler</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">getAssembler</span><span class="p">()</span>
<span class="n">f5</span> <span class="o">=</span> <span class="n">TACS</span><span class="o">.</span><span class="n">ToFH5</span><span class="p">(</span><span class="n">assembler</span><span class="p">,</span> <span class="n">TACS</span><span class="o">.</span><span class="n">PY_SOLID</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span>
<span class="n">f5</span><span class="o">.</span><span class="n">writeToFile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="s1">&#39;cantilever.f5&#39;</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="algorithms.html" title="Algorithms"
             >next</a> |</li>
        <li class="right" >
          <a href="interp.html" title="Interpolation between meshes"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">TMR 1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Graeme J. Kennedy.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>