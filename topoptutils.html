
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Topology Optimization Utilities &#8212; TMR 1 documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Orthogonal bracket" href="orthogonal_bracket.html" />
    <link rel="prev" title="Quad/octree-level classes" href="octree_interface.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="orthogonal_bracket.html" title="Orthogonal bracket"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="octree_interface.html" title="Quad/octree-level classes"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">TMR 1 documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="octree_interface.html"
                        title="previous chapter">Quad/octree-level classes</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="orthogonal_bracket.html"
                        title="next chapter">Orthogonal bracket</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/topoptutils.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="topology-optimization-utilities">
<h1>Topology Optimization Utilities<a class="headerlink" href="#topology-optimization-utilities" title="Permalink to this headline">¶</a></h1>
<p>TMR implements the class <a class="reference internal" href="#tmr.TMR.TopoProblem" title="tmr.TMR.TopoProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">TopoProblem</span></code></a> which is designed for topology optimization with ParOpt.
This class can be set up to contain information about how to evaluate the objective function and constraints using a TACS.Assembler object.
The adjoint derivative calculations for all members are implemented within the code.</p>
<ul>
<li><dl class="class">
<dt id="tmr.TMR.TopoProblem">
<em class="property">class </em><code class="sig-prename descclassname">tmr.TMR.</code><code class="sig-name descname">TopoProblem</code><a class="headerlink" href="#tmr.TMR.TopoProblem" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and stores information for topology optimization problems</p>
<dl class="method">
<dt id="tmr.TMR.TopoProblem.addBucklingConstraint">
<code class="sig-name descname">addBucklingConstraint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.addBucklingConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Add buckling/natural frequency constraints</p>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.addConstraints">
<code class="sig-name descname">addConstraints</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">case</em>, <em class="sig-param">funcs</em>, <em class="sig-param">offset</em>, <em class="sig-param">scale</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.addConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a list of constraints for the specified load case. The constraints
are specified as follows:</p>
<p>scale[i]*(funcs[i] + offset[i]) &gt;= 0</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>case</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Load case index to apply the constraints</p></li>
<li><p><strong>funcs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a>) – List of TACS.Function instances</p></li>
<li><p><strong>offset</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a>) – List of floats specifying the constraint offset</p></li>
<li><p><strong>scale</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a>) – List of scale value offsets</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.addFrequencyConstraint">
<code class="sig-name descname">addFrequencyConstraint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.addFrequencyConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Add buckling/natural frequency constraints</p>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.addLinearConstraints">
<code class="sig-name descname">addLinearConstraints</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vecs</em>, <em class="sig-param">offset</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.addLinearConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a set of load-case independent linear constraints represented
by the provided vectors. The constraints are imposed as:</p>
<p>dot(vecs[i], x) + offset[i] &gt;= 0.0</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vecs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a>) – List of ParOpt.PVec instances</p></li>
<li><p><strong>offset</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a>) – List of offsets for the constraints</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.addStressConstraint">
<code class="sig-name descname">addStressConstraint</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">case</em>, <em class="sig-param">sc</em>, <em class="sig-param">offset=1.0</em>, <em class="sig-param">scale=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.addStressConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a stress constraint formulated with stress reconstruction.</p>
<p>scale*(sc + offset) &gt;= 0</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>case</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Load case index</p></li>
<li><p><strong>sc</strong> (<em>StressConstraint</em>) – Stress constraint instance</p></li>
<li><p><strong>offset</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Constraint offset</p></li>
<li><p><strong>scale</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Constraint scaling</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.getAssembler">
<code class="sig-name descname">getAssembler</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.getAssembler" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Assembler object associated with the finest finite-element mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The finest Assembler ojbect</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Assembler</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.getFilter">
<code class="sig-name descname">getFilter</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.getFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the OctForest or QuadForest object associated with the finest
topology opt discretization.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The forest associated with the finest mesh</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="octree_interface.html#tmr.TMR.OctForest" title="tmr.TMR.OctForest">OctForest</a> or <a class="reference internal" href="octree_interface.html#tmr.TMR.QuadForest" title="tmr.TMR.QuadForest">QuadForest</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.getNumLoadCases">
<code class="sig-name descname">getNumLoadCases</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.getNumLoadCases" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of load cases set in the optimization problem</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of load cases</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.initialize">
<code class="sig-name descname">initialize</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the topology optimization instance. The optimization
problem cannot be solved before this call. After this call, no
more constraints can be added and the design problem is considered
fixed.</p>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.setF5EigenOutputFlags">
<code class="sig-name descname">setF5EigenOutputFlags</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">freq</em>, <em class="sig-param">elem_type</em>, <em class="sig-param">flag</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.setF5EigenOutputFlags" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the output frequency and data for generating an .f5 file for eigenvector
visualization. The elem_type and flag arguments dictate the type of data
to be written to the .f5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>freq</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Optimization iteration frequency to write the file</p></li>
<li><p><strong>elem_type</strong> (<em>ElementType</em>) – TACS element type</p></li>
<li><p><strong>flag</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Flag indicating the type of element data to write</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.setF5OutputFlags">
<code class="sig-name descname">setF5OutputFlags</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">freq</em>, <em class="sig-param">elem_type</em>, <em class="sig-param">flag</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.setF5OutputFlags" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the output frequency and data for generating an .f5 file for solution
visualization. The elem_type and flag arguments dictate the type of data
to be written to the .f5 file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>freq</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Optimization iteration frequency to write the file</p></li>
<li><p><strong>elem_type</strong> (<em>ElementType</em>) – TACS element type</p></li>
<li><p><strong>flag</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Flag indicating the type of element data to write</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.setInitDesignVars">
<code class="sig-name descname">setInitDesignVars</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">pvec</em>, <em class="sig-param">lbvec</em>, <em class="sig-param">ubvec</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.setInitDesignVars" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the initial design variables and lower and upper bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pvec</strong> (<em>PVec</em>) – ParOpt.PVec class storing the initial design vector</p></li>
<li><p><strong>lbvec</strong> (<em>PVec</em>) – ParOpt.PVec class storing the lower bound vector</p></li>
<li><p><strong>ubvec</strong> (<em>PVec</em>) – ParOpt.PVec class storing the upper bound vector</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.setIterationCounter">
<code class="sig-name descname">setIterationCounter</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">count</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.setIterationCounter" title="Permalink to this definition">¶</a></dt>
<dd><p>Set an offset for the iteration counter. All iteration counts will
start from the provided value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>count</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Iteration counter offset &gt;= 0</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.setLoadCases">
<code class="sig-name descname">setLoadCases</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">forces</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.setLoadCases" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the load cases to use within the optimization problem.
The input list of forces is used as a vector of right-hand-sides
within the TopoProblem solution method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>forces</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a>) – A list of TACS.Vec vector instances</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.setObjective">
<code class="sig-name descname">setObjective</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">weights</em>, <em class="sig-param">funcs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.setObjective" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the objective function for the design problem.</p>
<p>If no list of functions is provided, the weighted compliance is
assumed to be the objective. Otherwise a weighted sum of the functions
evaluaed for each load case is used. Note that if a weight is set to
zero, then the function and its gradient are not evaluated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weights</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a>) – List of weights on the compliance or function</p></li>
<li><p><strong>funcs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a>) – Optional list of TACS.Function instances</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="tmr.TMR.TopoProblem.setPrefix">
<code class="sig-name descname">setPrefix</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">_prefix</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.TopoProblem.setPrefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the file prefix for output generated by TopoProblem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>_prefix</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – File name prefix</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</li>
</ul>
<p>While you can create the <a class="reference internal" href="#tmr.TMR.TopoProblem" title="tmr.TMR.TopoProblem"><code class="xref py py-class docutils literal notranslate"><span class="pre">TopoProblem</span></code></a> from scratch, there are several utilities that can assist you with the creation of this object.
<a class="reference internal" href="#tmr.TopOptUtils.createTopoProblem" title="tmr.TopOptUtils.createTopoProblem"><code class="xref py py-meth docutils literal notranslate"><span class="pre">createTopoProblem()</span></code></a> generates a problem class with a specified hierarchy of octree or quadtree meshes.
The construction of the finite-element discretization and the topology parametrization are problem-specific, so these are generated through a callback.
Several additional helper functions are implemented to enable the creation of load vectors: <a class="reference internal" href="#tmr.TopOptUtils.computeVertexLoad" title="tmr.TopOptUtils.computeVertexLoad"><code class="xref py py-meth docutils literal notranslate"><span class="pre">computeVertexLoad()</span></code></a> creates a load vector from forces at named vertices,
<a class="reference internal" href="#tmr.TopOptUtils.computeTractionLoad" title="tmr.TopOptUtils.computeTractionLoad"><code class="xref py py-meth docutils literal notranslate"><span class="pre">computeTractionLoad()</span></code></a> creates a load vector based on traction on named edges or faces.
<a class="reference internal" href="#tmr.TopOptUtils.interpolateDesignVec" title="tmr.TopOptUtils.interpolateDesignVec"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interpolateDesignVec()</span></code></a> interpolates between design vectors after a refinement step.</p>
<ul>
<li><span class="target" id="module-tmr.TopOptUtils"></span><dl class="function">
<dt id="tmr.TopOptUtils.createTopoProblem">
<code class="sig-prename descclassname">tmr.TopOptUtils.</code><code class="sig-name descname">createTopoProblem</code><span class="sig-paren">(</span><em class="sig-param">forest</em>, <em class="sig-param">callback</em>, <em class="sig-param">filter_type</em>, <em class="sig-param">nlevels=2</em>, <em class="sig-param">repartition=True</em>, <em class="sig-param">design_vars_per_node=1</em>, <em class="sig-param">s=2.0</em>, <em class="sig-param">N=10</em>, <em class="sig-param">r0=0.05</em>, <em class="sig-param">lowest_order=2</em>, <em class="sig-param">ordering=5</em>, <em class="sig-param">scale_coordinate_factor=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tmr/TopOptUtils.html#createTopoProblem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tmr.TopOptUtils.createTopoProblem" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a topology optimization problem instance and a hierarchy of meshes.
This code takes in the OctForest or QuadForest on the finest mesh level
and creates a series of coarser meshes for analysis and optimization.
The discretization at each level is created via a callback function that
generates the appropriate TACSCreator object and its associated filter (the
QuadForest or OctForest on which the design parametrization is defined.)
The code then creates a TMRTopoFilter class which stores information about
the design parametrization and hierarchy. It creates a multigrid object and
finally a TMRTopoProblem instance for optimization.</p>
<p>The callback function takes in a forest object, corresponding to the finite-
element discretization and returns a creator object and a filter object in
the following form:</p>
<p>creator, filter = callback(forest)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>callback</strong> – A callback function that takes in the forest and
returns the filter and the associated creator class</p></li>
<li><p><strong>filter_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – Type of filter to create</p></li>
<li><p><strong>forest</strong> (<em>TMROctForest</em><em> or </em><em>TMRQuadForest</em>) – Forest type</p></li>
<li><p><strong>repartition</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Repartition the mesh</p></li>
<li><p><strong>design_vars_per_node</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – number of design variables for each node</p></li>
<li><p><strong>s</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Matrix filter smoothing parameter</p></li>
<li><p><strong>N</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Matrix filter approximation parameter</p></li>
<li><p><strong>r0</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Helmholtz filter radius</p></li>
<li><p><strong>lowest_order</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Lowest order mesh to create</p></li>
<li><p><strong>ordering</strong> – TACS Assembler ordering type</p></li>
<li><p><strong>scale_coordinate_factor</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Scale all coordinates by this factor</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The allocated topology optimization problem</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>problem (<a class="reference internal" href="#tmr.TMR.TopoProblem" title="tmr.TMR.TopoProblem">TopoProblem</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tmr.TopOptUtils.computeVertexLoad">
<code class="sig-prename descclassname">tmr.TopOptUtils.</code><code class="sig-name descname">computeVertexLoad</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">forest</em>, <em class="sig-param">assembler</em>, <em class="sig-param">point_force</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tmr/TopOptUtils.html#computeVertexLoad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tmr.TopOptUtils.computeVertexLoad" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a load at vertices with the given name value. The assembler object must
be created from the forest. The point_force must be equal to the number of
variables per node in the assembler object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – Name of the surface where the traction will be added</p></li>
<li><p><strong>forest</strong> (<a class="reference internal" href="octree_interface.html#tmr.TMR.QuadForest" title="tmr.TMR.QuadForest"><em>QuadForest</em></a><em> or </em><a class="reference internal" href="octree_interface.html#tmr.TMR.OctForest" title="tmr.TMR.OctForest"><em>OctForest</em></a>) – Forest for the finite-element mesh</p></li>
<li><p><strong>assembler</strong> (<em>Assembler</em>) – TACSAssembler object for the finite-element problem</p></li>
<li><p><strong>point_force</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a>) – List of point forces to apply at the vertices</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A force vector containing the point load</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Vec</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tmr.TopOptUtils.computeTractionLoad">
<code class="sig-prename descclassname">tmr.TopOptUtils.</code><code class="sig-name descname">computeTractionLoad</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">forest</em>, <em class="sig-param">assembler</em>, <em class="sig-param">trac</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tmr/TopOptUtils.html#computeTractionLoad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tmr.TopOptUtils.computeTractionLoad" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a surface traction to all quadrants or octants that touch a face or edge with
the given name. The assembler must be created from the provided forest. The list
trac must have a traction for each face (6) for octants or each edge (4) for
quadrants.</p>
<p>Note: This code uses the fact that the getOctsWithName or getQuadsWithName returns
the local face or edge index touching the surface or edge in the info member.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – Name of the surface where the traction will be added</p></li>
<li><p><strong>forest</strong> (<a class="reference internal" href="octree_interface.html#tmr.TMR.QuadForest" title="tmr.TMR.QuadForest"><em>QuadForest</em></a><em> or </em><a class="reference internal" href="octree_interface.html#tmr.TMR.OctForest" title="tmr.TMR.OctForest"><em>OctForest</em></a>) – Forest for the finite-element mesh</p></li>
<li><p><strong>assembler</strong> (<em>Assembler</em>) – TACSAssembler object for the finite-element problem</p></li>
<li><p><strong>trac</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a>) – List of tractions, one for each possible face/edge orientation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A force vector containing the traction</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Vec</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tmr.TopOptUtils.compute3DTractionLoad">
<code class="sig-prename descclassname">tmr.TopOptUtils.</code><code class="sig-name descname">compute3DTractionLoad</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">forest</em>, <em class="sig-param">assembler</em>, <em class="sig-param">tr</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tmr/TopOptUtils.html#compute3DTractionLoad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tmr.TopOptUtils.compute3DTractionLoad" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a constant surface traction to all octants that touch a face or edge with
the given name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>forest</strong> (<a class="reference internal" href="octree_interface.html#tmr.TMR.QuadForest" title="tmr.TMR.QuadForest"><em>QuadForest</em></a><em> or </em><a class="reference internal" href="octree_interface.html#tmr.TMR.OctForest" title="tmr.TMR.OctForest"><em>OctForest</em></a>) – Forest for the finite-element mesh</p></li>
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – Name of the surface where the traction will be added</p></li>
<li><p><strong>assembler</strong> (<em>Assembler</em>) – TACSAssembler object for the finite-element problem</p></li>
<li><p><strong>tr</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a>) – The 3D components of the traction.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A force vector containing the traction</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Vec</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tmr.TopOptUtils.interpolateDesignVec">
<code class="sig-prename descclassname">tmr.TopOptUtils.</code><code class="sig-name descname">interpolateDesignVec</code><span class="sig-paren">(</span><em class="sig-param">orig_filter</em>, <em class="sig-param">orig_vec</em>, <em class="sig-param">new_filter</em>, <em class="sig-param">new_vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tmr/TopOptUtils.html#interpolateDesignVec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tmr.TopOptUtils.interpolateDesignVec" title="Permalink to this definition">¶</a></dt>
<dd><p>This function interpolates a design vector from the original design space defined
on an OctForest or QuadForest and interpolates it to a new OctForest or QuadForest.</p>
<p>This function is used after a mesh adaptation step to get the new design space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orig_filter</strong> (<a class="reference internal" href="octree_interface.html#tmr.TMR.OctForest" title="tmr.TMR.OctForest"><em>OctForest</em></a><em> or </em><a class="reference internal" href="octree_interface.html#tmr.TMR.QuadForest" title="tmr.TMR.QuadForest"><em>QuadForest</em></a>) – Original filter Oct or QuadForest object</p></li>
<li><p><strong>orig_vec</strong> (<em>PVec</em>) – Design variables on the original mesh in a ParOpt.PVec</p></li>
<li><p><strong>new_filter</strong> (<a class="reference internal" href="octree_interface.html#tmr.TMR.OctForest" title="tmr.TMR.OctForest"><em>OctForest</em></a><em> or </em><a class="reference internal" href="octree_interface.html#tmr.TMR.QuadForest" title="tmr.TMR.QuadForest"><em>QuadForest</em></a>) – New filter Oct or QuadForest object</p></li>
<li><p><strong>new_vec</strong> (<em>PVec</em>) – Design variables on the new mesh in a ParOpt.PVec (set on ouput)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tmr.TopOptUtils.addNaturalFrequencyConstraint">
<code class="sig-prename descclassname">tmr.TopOptUtils.</code><code class="sig-name descname">addNaturalFrequencyConstraint</code><span class="sig-paren">(</span><em class="sig-param">problem</em>, <em class="sig-param">omega_min</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tmr/TopOptUtils.html#addNaturalFrequencyConstraint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tmr.TopOptUtils.addNaturalFrequencyConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a natural frequency constraint to a TopoProblem optimization problem</p>
<p>This function automatically sets good default arguments that can be
overridden with keyword arguments passed in through kwargs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>problem</strong> (<a class="reference internal" href="#tmr.TMR.TopoProblem" title="tmr.TMR.TopoProblem"><em>TopoProblem</em></a>) – TopoProblem optimization problem</p></li>
<li><p><strong>omega_min</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – Minimum natural frequency, Hz</p></li>
<li><p><strong>**kwargs</strong> – Frequency constraint parameters; check
TMR documentation for more detail</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tmr.TopOptUtils.densityBasedRefine">
<code class="sig-prename descclassname">tmr.TopOptUtils.</code><code class="sig-name descname">densityBasedRefine</code><span class="sig-paren">(</span><em class="sig-param">forest</em>, <em class="sig-param">assembler</em>, <em class="sig-param">index=0</em>, <em class="sig-param">lower=0.05</em>, <em class="sig-param">upper=0.5</em>, <em class="sig-param">reverse=False</em>, <em class="sig-param">min_lev=0</em>, <em class="sig-param">max_lev=30</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tmr/TopOptUtils.html#densityBasedRefine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tmr.TopOptUtils.densityBasedRefine" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a density-based refinement criteria.</p>
<p>This function takes in a Quad or OctForest that has been used for analysis and its
corresponding Assembler object. It then uses the data set in the constitutive object
to extract the density within each element. If the density falls below the the bound
<em>lower</em> the element is coarsened, if the density exceeds <em>upper</em> the element is
refined. If <em>reverse</em> is set, this scheme is reversed so low design values are
refined. The refinement is applied directly to the forest.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>forest</strong> (<a class="reference internal" href="octree_interface.html#tmr.TMR.QuadForest" title="tmr.TMR.QuadForest"><em>QuadForest</em></a><em> or </em><a class="reference internal" href="octree_interface.html#tmr.TMR.OctForest" title="tmr.TMR.OctForest"><em>OctForest</em></a>) – OctForest or QuadForest to refine</p></li>
<li><p><strong>assembler</strong> (<em>Assembler</em>) – The TACS.Assembler object associated with forest</p></li>
<li><p><strong>index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – The index used in the call to getDVOutputValue</p></li>
<li><p><strong>lower</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the lower limit used for coarsening</p></li>
<li><p><strong>upper</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – the upper limit used for refinement</p></li>
<li><p><strong>reverse</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – Reverse the refinement scheme</p></li>
<li><p><strong>min_lev</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Minimum refinement level</p></li>
<li><p><strong>max_lev</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Maximum refinement level</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="tmr.TopOptUtils.TopologyOptimizer">
<em class="property">class </em><code class="sig-prename descclassname">tmr.TopOptUtils.</code><code class="sig-name descname">TopologyOptimizer</code><span class="sig-paren">(</span><em class="sig-param">problem</em>, <em class="sig-param">options={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/tmr/TopOptUtils.html#TopologyOptimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tmr.TopOptUtils.TopologyOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimizer wrapper for topology optimization problems</p>
<dl class="method">
<dt id="tmr.TopOptUtils.TopologyOptimizer.optimize">
<code class="sig-name descname">optimize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/tmr/TopOptUtils.html#TopologyOptimizer.optimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#tmr.TopOptUtils.TopologyOptimizer.optimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the optimization problem using the settings. Runs either InteriorPoint
or TrustRegion optimization problems</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Optimized design point x</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>PVec</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</li>
<li><dl class="function">
<dt id="tmr.TMR.convertPVecToVec">
<code class="sig-prename descclassname">tmr.TMR.</code><code class="sig-name descname">convertPVecToVec</code><span class="sig-paren">(</span><em class="sig-param">pvec</em><span class="sig-paren">)</span><a class="headerlink" href="#tmr.TMR.convertPVecToVec" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a ParOpt.PVec class to a TACS.Vec class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pvec</strong> (<em>PVec</em>) – A vector generated by TopoProblem</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A TACS.Vec instance</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Vec</p>
</dd>
</dl>
</dd></dl>

</li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="orthogonal_bracket.html" title="Orthogonal bracket"
             >next</a> |</li>
        <li class="right" >
          <a href="octree_interface.html" title="Quad/octree-level classes"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">TMR 1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Graeme J. Kennedy.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.2.
    </div>
  </body>
</html>